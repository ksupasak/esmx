

class Project < ApplicationRecord
  
  self.table_name =  :esm_projects
  # attr_accessor :name,:title,:extended,:acl,:package,:description,:user_id,:database_id,:dependencies,:params,:esm_id,:domain
  
  belongs_to :esm
  
  has_one :schema
  has_many :services,:dependent => :delete_all, :autosave => true
  has_many :menu_actions, :dependent => :delete_all
  has_many :documents,:dependent => :delete_all
  has_many :settings,:dependent => :delete_all

  
  has_many :roles, :dependent =>:delete_all
  
  
  
  after_create :filter_after_create

  validates_uniqueness_of :name, :scope => :esm_id
  validates_uniqueness_of :package
  
  attr_accessor :project_instance

  def filter_after_create
  
    unless self.extended 
      home_service = self.services.create :name=>'home'
      html = ScriptTemplate.find_by_name 'HTMLTemplate'
      layout_template = ScriptTemplate.find_by_name 'LayoutTemplate'
      home_service.operations.create :name=>'index',:template_id=>html.id,:command=>"<h1>Hello world</h1><br>\n<i>This is generated by system.</i>"
      home_service.operations.create :name=>'layout',:template_id=>layout_template.id,:command=>'<%=default_layout%>'
    end
    
  end
  
  
  after_initialize :after_find_func

   def after_find_func
     # @project_instance = init_instance
   end
  
  def get_mapping_master list=nil
          instance = get_instance
          docs = instance[:documents]
          unless list
             
                  list = docs.collect{|i| i.name }
                  
          end
          
          hash = {}
          for i in list
                doc = get_document i
                
                hash[i] = doc.get_mapping_values if doc
          end
         return hash
        
  end
  
  before_save :filter_before_save
  def filter_before_save
      # puts "vvv "+ self.params 
      # self.params = self.params.to_json
      self.package = "#{self.esm.name}.#{self.name}"
  end

  def before_destroy
        self.services.destroy_all
  end
  
  def to_s
       return self.title if self.title
       return self.name.humanize  if self.name
       return 'Untitled'
  end
  
  def get_schema
      self.schema = Schema.find_or_create_by(:name=>self.package) {|s|
             s.esm_id=self.esm_id
             s.project_id=self.id 
      } 
      return self.schema
  end
  
  
  def get_user_by_id id
      
      role = 'user'
      models = get_model
      user_model = models[:user] 
      user = user_model.find(id)
      if user
           
           r = models[:role].find(user.role)
           role = r.name if r
      end
      
      return user,role       
        
  end


#  /////////////////////////////////////////////////////////////////////////////
#  model methods 
#  /////////////////////////////////////////////////////////////////////////////

  def load_model model_name=nil
    get_schema.load_model(self.get_instance, model_name)
  end

  def get_model model_name=nil
    load_model model_name
  end

  def attachment_model
    get_schema.attachment_model
  end

#  /////////////////////////////////////////////////////////////////////////////
#  content methods 
#  ///////////////////////////////////////////////////////////////////////////// 

  def content_path
    path =  "esm/#{self.esm.name}/#{self.name}/content"
    file_path = "public/#{path}"
    p = file_path.split('/')
    i=0
    unless FileTest.exist?(file_path)
      while(s = "public/esm/#{p[2...2+i].join('/')}" and s!=file_path)
        Dir.mkdir(s) unless FileTest.exist?(s)
        i+=1
      end
      Dir.mkdir(s) unless FileTest.exist?(s)
    end
    return path
  end

  def content sub_path='.'
  
    path = self.content_path
    file_path = "public/#{path}/#{sub_path}"
    # puts file_path
    r = []
    Dir.entries(file_path).each do |i|
  
    p = File.join(i) 
    if p[0..0]!='.' 
    if FileTest.directory?( File.join(file_path,p) )
      r<<{:text=>"#{i}",
    	  :cls=>'folder',
    	  :node=>p,
  			:leaf=>false,"checked"=> false,
        :action=>"/esm_content/#{self.id}?path=#{File.join(sub_path,p)}"
     
  	  }
  	else
  	   r<<{:text=>"#{i}",
      	  :cls=>'folder',
      	  :node=>p,
    			:leaf=>true,"checked"=> false,
          :action=>"content?id=#{self.id}&path=#{File.join(sub_path,p)}",
          :url=>"/#{path}/#{sub_path}/#{p}"
  		  }
    end
  end
    end
    return r
  end
  
  def content_upload_file io, sub_path
    path = self.content_path
    file_path = File.join("public",path,sub_path,io.original_filename)
    File.open(file_path, "wb") { |file| file << io.read }
    url = "/#{path}/#{sub_path}/#{io.original_filename}"
  end
  
  def content_mkdir name, sub_path
    path = self.content_path
    file_path = File.join("public",path,sub_path,name)
    Dir.mkdir(file_path)
  end
  
  def content_rmdir name, sub_path
    path = self.content_path
    file_path = File.join("public",path,sub_path,name)
    Dir.rmdir(file_path)
  end
  
 
#  /////////////////////////////////////////////////////////////////////////////
#  accessibility methods 
#  ///////////////////////////////////////////////////////////////////////////// 
  
  def get_home_url request,action='index'
    subdomain = request.host.split('.')
    # puts "subdomain #{subdomain} #{DOMAIN.split(".")[0]}"
    if subdomain[0]!=DOMAIN.split(".")[0] and subdomain[0]!='localhost' and subdomain[0]!='192' and subdomain[0].to_i==0
      subdomain= subdomain[0]
      @solution_mode = true 
    end
    if @solution_mode
      return "/#{self.name}/Home/#{action}"
    else
      return "/#{self.esm.name}/#{self.name}/Home/#{action}"
    end
    
  end
  
  def url domain=nil
         if domain and domain==self.domain
         return "/s/Home/index"
         else
         return "/#{self.package.split('.').join('/')}/Home/index"
        end
   end
   
   def self.params_list
     # app_title
     # app_logo_url
     # app_banner_url
     # app_copyright 
     # app_theme
     # app_css
     # app_bg_style
     list =  %w{
       app_title
       app_logo_url
       app_theme
     }
   end
   
   def get_params
      r = {}
      begin
      if self.params and self.params!='' and self.params!='null'
        # r = YAML::load(self.params)
        # r = JSON.parse(self.params)
        
        
     
        
        begin
            r = JSON.parse(self.params)
        rescue JSON::ParserError => e  
            r = eval(self.params)
        end 
        
  
        
        return r
      else
        return {}
      end
      
      rescue Exception=>e
        return {}
      end
   end

 #  /////////////////////////////////////////////////////////////////////////////
 #  virtual instance methods 
 #  /////////////////////////////////////////////////////////////////////////////



   def get_instance 
      @instance = init_instance unless @instance
      return  @instance
   end


   def get_refresh_instance 
      @instance = init_instance
      return  @instance
   end
   
   def get_super_project
     return Project.find_by_package(self.extended)
   end
   
   def init_instance 
   
      list = {:menus=>[],:services=>[],:documents=>[],:tables=>[],:settings=>[]}
      
      if self.extended and self.extended!=''
          project = get_super_project 
          if project
            list = project.get_instance 
          end
      end 
    
        
      services = self.services.select("id,name,title,package").to_a
      actions = self.menu_actions.root.select("id,name,title").to_a
      documents = self.documents.select("id,name,data").to_a
      tables = self.get_schema.tables.select("id,name").to_a
      settings = self.settings.to_a
      
      
      
      # ============== actions
      table = {}
      order = []
      list[:menus].each do |i|
        table[i.name] = i
        order<<i.name
      end
      actions.each do |i|
        if table[i.name]
          table[i.name] = i
        else
          table[i.name] = i
          order<<i.name
        end
      end
      list[:menus]= order.collect{|i| table[i]}
      
      # ============== services
      table={}
      order=[]
      list[:services].each do |i|
        table[i.name] = i
        order<<i.name
      end
      services.each do |i|
        if table[i.name]
          table[i.name] = i
        else
          table[i.name] = i
          order<<i.name
        end
      end
      list[:services]= order.collect{|i| table[i]}
      
      # ============== documents
      table={}
      order=[]
      list[:documents].each do |i|
        table[i.name] = i
        order<<i.name
      end
      documents.each do |i|
        if table[i.name]
          table[i.name] = i
        else
          table[i.name] = i
          order<<i.name
        end
      end
      list[:documents]= order.collect{|i| table[i]}
      
      
      # ============== tables
      table={}
      order=[]
      list[:tables].each do |i|
        table[i.name] = i
        order<<i.name
      end
      tables.each do |i|
        if table[i.name]
          table[i.name] = i
        else
          table[i.name] = i
          order<<i.name
        end
      end
      list[:tables]= order.collect{|i| table[i]}
      
      # ============== settings
       table={}
       order=[]
       list[:settings].each do |i|
         table[i.name] = i
         order<<i.name
       end
       settings.each do |i|
         if table[i.name]
           table[i.name] = i
         else
           table[i.name] = i
           order<<i.name
         end
       end
       list[:settings]= order.collect{|i| table[i]}
      

   return list
  
  end

  def get_document name
     instance = get_instance
     instance[:documents].each do |i|
       if i.name == name
         doc = Document.find(i.id)
         doc.project = self
        return doc
       end
       
     end
    
    return nil
  end

  def get_service name
     instance = get_instance
     instance[:services].each do |i|
       if i.name == name
         doc = Service.find(i.id)
         doc.project = self
        return doc
       end
       
     end
    
    return nil
  end
  
  def get_services_by_abstract class_name
    list = []
      instance = get_instance
      Service.find(instance[:services].collect{|i| i.id}).each do |i|
        if i.extended==class_name
          list<<i
        else
           #    
           service = i
           # while project and project.extended
           while service and service.extended and service.extended!=""
           super_service = Service.find_by_package service.extended
           #list<<super_project
           if super_service and super_service.extended==class_name
                list << i 
           end
           service = super_service
           end
        end
    end
    list
  end 
  
  

  
   
 #  /////////////////////////////////////////////////////////////////////////////
 #  migration methods 
 #  /////////////////////////////////////////////////////////////////////////////
   
    def xml_attr name, ele
      ele.elements.each("#{name}") { |element| self[name] = element.text }
    end


    def import ele , force=true
           xml_attr :name ,ele
           xml_attr :package ,ele
           xml_attr :extended ,ele
           xml_attr :domain ,ele
           xml_attr :title ,ele
           self.save

        if force
            self.services.destroy_all
            ele.elements.each("services/service") do |element| 
              s = self.services.new
              s.import element
            end
         end

    end
    
    def update_settings params
      settings = get_instance[:settings]
      hash = {}
      for i in settings
        hash[i.name]=i
      end
      
      puts settings.inspect
      
      params.each_pair do |k,v|
          obj = hash[k]
          if obj.project_id == self.id
            obj.update :value=>v
          else
            if v!=obj.value
              self.settings.create :name=>k,:value=>v
            end
          end
      end

    end
    
    def setting name
       settings = get_instance[:settings]
       hash = {}
       for i in settings
         hash[i.name]=i
       end
       if hash[name]
       return hash[name].value 
       else
       return nil
       end
    end
    def get_setting name
        setting name
    end
   
   
  
end

